#!/usr/bin/env python
# -*- coding: utf-8 -*-

"""
模型项目入口文件示例
使用 data_analysis 包处理充电站数据

使用说明:
1. 安装 data_analysis 包: pip install data_analysis-2.0.0-py3-none-any.whl
2. 将此文件复制到你的模型项目根目录并重命名为 main.py
3. 在同目录下创建 config.yaml 配置文件（可从 config.yaml.example 复制）
4. 修改 config.yaml 中的 module_name 为你的模块名称
5. 实现 my_model_predict 函数中的模型推理逻辑，或导入已封装好的模型推理函数入口
6. 运行: python main.py
"""

import asyncio
import logging
import sys
import time
from pathlib import Path

# 配置日志
logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s - %(name)s - %(levelname)s - %(message)s",
    handlers=[
        logging.StreamHandler(sys.stdout),
        logging.FileHandler("model_service.log", encoding="utf-8"),
    ],
)

# 导入 data_analysis 包
from d_a.analysis_service import AsyncDataAnalysisService
from d_a.kafka_client import AsyncKafkaProducerClient
from d_a.config import KAFKA_CONFIG, MODULE_OUTPUT_TOPICS, MODULE_NAME


# ===================== 模型推理函数，模型封装入口范例（异步） =====================
async def my_model_predict(module_input):
    """
    模型推理函数 - 请根据你的实际模型替换此函数

    Args:
        module_input: dict, 包含该场站的所有输入数据
            例如:
            {
                "_data_quality": {
                    "availability_ratio": 0.8333333333333334,
                    "available_topics": [
                        "SCHEDULE-STATION-PARAM",
                        "SCHEDULE-CAR-ORDER",
                        "SCHEDULE-CAR-PRICE",
                        "SCHEDULE-DEVICE-HOST-DCDC",
                        "SCHEDULE-DEVICE-STORAGE",
                    ],
                    "missing_topics": ["MODULE-OUTPUT-PV_PREDICTION"],
                    "total_topics": 6,
                },
                "car_order": [
                    {
                        "batteryNominalTotalCapacity": 111.1,
                        "carProducerCode": "0000000000000000",
                        "endChargeTime": "2070-01-02 08:00:01",
                        "gunNo": "01",
                        "hostCode": "52000000000631",
                        "outputPower": 229.7,
                        "soc": 58.52,
                        "startChargeTime": "2025-11-19 11:55:09",
                        "stationId": "1173980655843938304",
                        "terminalMaxOutElectric": 0.0,
                        "terminalRequireElectric": 230.0,
                        "terminalRequireVoltage": 999.0,
                        "transactionSerialNo": "5200000000063101190B130B370813F3",
                    }
                ],
                "device_storage": [
                    {
                        "batteryGroupElectric": 11.2,
                        "batteryGroupOutPower": 4,
                        "batteryGroupSoc": 12,
                        "batteryGroupSoh": 9,
                        "hostCode": "52000000000631",
                        "maxTemperature": 40.0,
                        "minTemperature": 5.0,
                        "stationId": "1173980655843938304",
                        "storageCode": "BDDDDD74DAD2CD6B095D",
                    }
                ],
                "gridCapacity": 1.0,
                "gunNum": 0,
                "hostCode": ["52000000000631"],
                "powerNum": 0,
                "stationId": "1173980655843938304",
                "stationLat": 0.0,
                "stationLng": 0.0,
            }
    Returns:
        dict: 模型预测结果
    """
    # TODO: 替换为你的实际模型推理逻辑
    # 示例: 调用你的模型
    # result = your_model.predict(module_input)

    # 当前为示例返回
    logging.info(f"处理输入数据: {list(module_input.keys())}")

    # 模拟模型推理
    await asyncio.sleep(0.01)  # 模拟推理耗时

    return {
        "prediction": "example_result",
        "confidence": 0.95,
        "timestamp": time.time(),
    }


# ===================== 回调函数 =====================
async def my_callback(station_id, module_input):
    """
    单场站处理回调
    
    Args:
        station_id: str, 场站ID
        module_input: dict, 模块输入数据
    
    Returns:
        dict: 必须包含 'station_id' 字段的结果字典
        None: 处理失败
    """
    try:
        # 调用模型推理
        result = await my_model_predict(module_input)
        
        # 在结果中添加 station_id（必需）
        result["station_id"] = station_id
        
        logging.info(f"场站 {station_id} 处理成功")
        return result
        
    except Exception as e:
        logging.error(f"场站 {station_id} 处理失败: {e}", exc_info=True)
        return None  # 返回None表示失败,不会阻塞批次上传


async def batch_upload_handler(producer, output_topic, batch_id, results_list):
    """
    批次上传回调
    
    Args:
        producer: Kafka生产者
        output_topic: 输出topic
        batch_id: str, 批次ID
        results_list: list, 成功场站的结果列表
    """
    if not results_list:
        logging.warning(f"批次 {batch_id} 没有成功的结果,跳过上传")
        return

    payload = {
        "batch_id": batch_id,
        "module": MODULE_NAME,
        "timestamp": time.time(),
        "stations_count": len(results_list),
        "results": results_list,  # 所有场站的结果列表
    }

    try:
        await producer.send(output_topic, payload)
        logging.info(f"批次上传成功: {batch_id}, {len(results_list)} 个场站")
    except Exception as exc:
        logging.error(f"批次上传失败: {batch_id}", exc_info=exc)


# ===================== 主函数 =====================
async def main():
    """主函数 - 启动数据分析服务"""
    
    # 获取输出topic
    output_topic = MODULE_OUTPUT_TOPICS.get(MODULE_NAME)
    if not output_topic:
        raise RuntimeError(f"未配置模块 {MODULE_NAME} 的输出topic")
    
    logging.info(f"启动模块: {MODULE_NAME}")
    logging.info(f"输出topic: {output_topic}")
    
    # 创建Kafka生产者
    producer = AsyncKafkaProducerClient(KAFKA_CONFIG)
    await producer.start()
    logging.info("Kafka生产者已启动")
    
    # 创建数据分析服务
    service = AsyncDataAnalysisService(module_name=MODULE_NAME)
    
    # 定义批次上传处理器
    async def upload_handler(batch_id, results_list):
        await batch_upload_handler(producer, output_topic, batch_id, results_list)
    
    # 启动服务
    await service.start(callback=my_callback, batch_upload_handler=upload_handler)
    logging.info("数据分析服务已启动")
    
    try:
        # 打印服务状态
        print("\n" + "="*60)
        print(f"服务已启动 - 模块: {MODULE_NAME}")
        print(f"多消费者模式: {service.consumer._multi_consumer_mode}")
        
        if service.consumer._multi_consumer_mode:
            print(f"订阅的 topic 数量: {len(service.consumer._topic_consumers)}")
            for topic in service.consumer._topic_consumers.keys():
                print(f"  - {topic}")
        
        print("按 Ctrl+C 停止服务...")
        print("="*60 + "\n")
        
        # 主循环
        iteration = 0
        while True:
            iteration += 1
            
            # 每隔10次迭代显示状态信息
            if iteration % 10 == 0:
                status = service.get_station_status()
                logging.info(f"第 {iteration} 次循环 - 活跃场站数: {len(status)}")
                
                # 显示消息积压信息（多消费者模式）
                if service.consumer._multi_consumer_mode:
                    lag_info = service.consumer.get_lag_info()
                    if lag_info:
                        logging.info("消息积压情况:")
                        for topic, partitions in lag_info.items():
                            logging.info(f"  {topic}: {len(partitions)} 个分区")
            
            # 使用多个短暂的 sleep 以提高响应性
            for _ in range(10):
                await asyncio.sleep(1)
                
    except (KeyboardInterrupt, asyncio.CancelledError) as e:
        logging.info(f"收到停止信号: {type(e).__name__},开始停机...")
        
    finally:
        logging.info("正在停止服务...")
        await service.stop()
        
        logging.info("正在停止生产者...")
        await producer.stop()
        
        logging.info("服务已完全停止")


if __name__ == "__main__":
    """
    程序入口
    
    运行前确保:
    1. 已安装 data_analysis 包
    2. 当前目录下有 config.yaml 配置文件
    3. config.yaml 中正确配置了 module_name 和 Kafka 连接信息
    """
    
    # 检查配置文件
    config_file = Path("config.yaml")
    if not config_file.exists():
        print("错误: 找不到 config.yaml 配置文件")
        print("请从 config.yaml.example 复制并修改配置")
        sys.exit(1)
    
    # 创建并运行事件循环
    loop = asyncio.new_event_loop()
    asyncio.set_event_loop(loop)
    
    try:
        loop.run_until_complete(main())
    except KeyboardInterrupt:
        logging.info("捕获到键盘中断")
    finally:
        logging.info("关闭事件循环...")
        loop.close()
        logging.info("程序已退出")
